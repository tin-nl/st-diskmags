
		GFA COMMANDS #5
			BY MICHAEL SCHUESSLER

So, this here is the last of our GFA Commands series, I hope that
it was of some use to you, maybe I will continue with newer commands 
in the next issue.

				

      WRITE

HOW:       WRITE [ expressions ][ ; ]
           WRITE #n [ expressions ][ ; ]

EG:        OPEN "O",#1,"DAT"
           WRITE #1,"SMITH","JOHN",18
           CLOSE #1

PURPOSE:   STORES DATA IN A SEQUENTIAL FILE TO BE READ WITH INPUT.
           UNLIKE THE PRINT COMMAND THE NUMBERS ARE SEPARATED BY
           COMMAS AND THE STRINGS ARE ENCLOSED IN QUOTES.
           (SEE ALSO PRINT)
 

      SPECIAL FUNCTIONS


      *

HOW:       *

EG:        DIM A$(9)
           FOR I=0 TO 9
             A$(I)=STR$(RND)
           NEXT I
           @DSP
           @SORT(*A$())
           @DSP
           PROCEDURE DSP
             FOR I=0 TO 9
               PRINT A$
             NEXT I
           RETURN
           PROCEDURE SORT(P.SARR)         !SORT X$()
             IF TYPE(P.SARR)<>5
               ERROR 47                   !STRING PARAMETER
             END IF
             SWAP *P.SARR,X$()              !WORK FIELD
             LOCAL I%,J%
             REM BUBBLESORT SLOW
             FOR I%=DIM?(X$())-2 DOWNTO 0
               FOR J%=0 TO I%
                 IF X$(J%)>X$(J%+1)
                   SWAP X$(J%),X$(J%+1)         
                 ENDIF
               NEXT J%
             NEXT I%
             SWAP *P.SARR,X$()              !FIELD RETURN
           RETURN

PURPOSE:   PASSES ON VARIALBLES AND ARRAYS INDIRECTLY.
           THE ASTERIX IS NOT ONLY FOR MULTIPLICATION BUT ALSO
           SIGNIFIES THE INDIRECT ADDRESSING IN PROCEDURES WITH
           PARAMETERS OR FIELDS TO BE RETURNED.

           GOSUB XXX(*A) DOES NOT SPECIFY THE VALUE OF 'A' BUT
           IT'S ADDRESS. *PTR=5 SETS THE VARIABLE WHOSE ADDRESS
           IS CONTAINED IN PTR TO 5.
           WITH FIELDS IT IS ONLY POSSIBLE TO CHANGE AN ELEMENT OF
           THE FIELD BY MEANS OF AN INDIRECT SWAP. TYPE() SHOWS
           WHAT SORT OF VARIABLE IS AT THE POINTER LOCATION.
           IMPORTANT  LOCAL VARIABLES AND GLOBAL VARIABLES WITH
           THE SAME NAME ARE STORED IN THE SAME AREA (THE GLOBAL
           VALUES ARE SAVED WHEN LOCAL BEGINS AND RESTORED ON
           RETURN). THEREFORE LOCAL VARIABLES MAY NOT HAVE THE
           NAME OF A RETURN PARAMETER.
           
      ==

HOW:       a==b

EG:        FOR I=-1 TO 0 STEP 0.1
             EXIT IF I==0.5
           NEXT I
           PRINT I

PURPOSE:   COMPARISON OPERATOR FOR APPROXIMATELY EQUAL

           'a' AND 'b' ARE NUMERIC EXPRESSIONS. THE == OPERATOR IS
           USED IN THE SAME WAY AS A COMPARISON WITH = EXCEPT THAT
           THE CONDITION IS TRUE NOT ONLY WHEN THE TWO ARE EQUAL,
           BUT WHEN THEY ARE APPROXIMATLEY EQUAL.  28 BITS OF THE
           MANTISSA ARE COMPARED i.e. ABOUT 8.5 DIGITS.  IN THE
           EXAMPLE THE LOOP IS LEFT ALTHOUGH IT IS POSSIBLE THAT
           DUE TO ROUNDING ERRORS THE NUMERIC VARIABLE IS NEVER
           EXACTLY 0.5

           (see DEFNUM and PRINT USING)


      BASEPAGE

HOW:       BASEPAGE

EG:        VOID GEMDOS(&H1A,BASEPAGE+128)
           P$="*.*"+CHR$(0)
           STAT=GEMDOS(&H4E,L:VARPTR(P$),8)
           D.name$=""
           IF STAT=0                      ! <>0 Something wrong
              I%=BASEPAGE+30
              WHILE PEEK(I%)
                D.name$=D.name$+CHR$(PEEK(I%))
                INC I%
              WEND
           END IF

PURPOSE:   RETURNS THE ADDRESS OF THE BASEPAGE OF GFA-BASIC

           EVERY PROGRAM THAT IS LOADED UNDER GEMDOS IS ASSIGNED A
           BASEPAGE WHICH HAS A LENGTH OF 256 BYTES.  THE FIRST 
           128 BYTES OF THIS PAGE CONTAIN INTERNAL INFORMATION
           THAT THE OPERATING SYSTEM NEEDS TO ORGANISE PROGRAMS IN
           MEMORY - A POKE HERE CAN, AMONGST OTHER THINGS, LEAD TO
           SYSTEM BREAKDOWN ON 'QUIT'.

           THE SECOND HALF OF THE BASEPAGE CONTAINS THE COMMAND
           LINE.  THE FIRST 44 BYTES OF THE SECOND HALF ARE USED,
           THE REST CAN, FOR EXAMPLE, BE USED FOR SMALL MACHINE
           CODE PROGRAMS WHICH RETURN JOYSTICK INFORMATION.


      BITBLT

HOW:       BITBLT s%(),d%(),p%()

PURPOSE:   RASTER COPYING COMMAND.

           's%' CONTAINS THE SOURCE MEMORY FORM DESCRIPTOR - THE
                DESCRIPTION OF THE SOURCE RASTER
           'd%' CONTAINS THE DESTINATION MEMORY FORM DESCRIPTOR -
                THE DESCRIPTION OF THE DESTINATION RASTER
           'p%' CONTAINS THE CO-ORDINATES OF THE TWO EQUALLY 
                SIZED RECTANGLES AND THE COPYING MODE (see PUT).
                THESE FIELDS MUST BE AS FOLLOWS:

           s%(0) = RASTER ADDRESS (EVEN)  e.g. XBIOS(3)
           s%(1) = RASTER WIDTH IN POINTS e.g. 640 (MUST BE
                   DIVISIBLE BY 16)
           s%(2) = RASTER HEIGHT IN POINTS e.g. 400
           s%(3) = RASTER WIDTH IN WORDS e.g. 40, i.e. s%(1)/16
           s%(4) = ALWAYS 0
           s%(5) = NUMBER OF BIT PLANES (e.g. 2/4)
           d%()    as s%()
           p%(0...3) = SOURCE RECTANGLE (x0,y0,x1,y1)
           p%(4...7) = DESTINATION RECTANGLE (AS ABOVE)
           p%(8)     = MODE (see PUT)


      BGET

HOW:       BGET [#] i,adr,cnt

EG:        OPEN "I",#1,"SCR.DAT"
           SEEK #1,8000
           BGET #1,XBIOS(3)+24000,8000
           CLOSE #1

PURPOSE:   READS FROM A DATA CHANNEL INTO AN AREA OF MEMORY

           'i', 'adr' AND 'cnt' ARE INTEGER EXPRESSIONS.
           'i' IS A CHANNEL NUMBER.
           'cnt' BYTES ARE READ IN AND STORED IN MEMORY STARTING 
                 AT ADDRESS 'adr'
           UNLIKE BLOAD, SEVERAL DIFFERENT AREAS OF MEMORY CAN BE
           READ FROM A FILE.  IN THE EXAMPLE, THE SECOND QUARTER
           OF THE SCREEN FILE IS READ INTO THE BOTTOM EDGE OF THE
           SCREEN.

           (see BPUT, BSAVE, BLOAD)


      BMOVE

HOW:       BMOVE scr,dst,cnt

EG:        BMOVE XBIOS(3),XBIOS(3)+2,31998

PURPOSE:   FAST MOVEMENT OF MEMORY BLOCKS
      
           'scr', 'dst' AND 'cnt' ARE INTEGER EXPRESSIONS.
           'scr' IS THE ADDRESS AT WHICH THE BLOCK TO BE MOVED
                 BEGINS.
           'dst' IS THE ADDRESS TO WHICH THE BLOCK IS TO MOVED
           'cnt' IS THE LENGTH OF THE BLOCK IN BYTES.
           BMOVE IS A FAST, INTELLIGENT MOVING ROUTINE WHICH MEANS
           THAT IT IS ALSO SUITABLE FOR OVERLAPPING SOURCE AND
           DESTINATION ADDRESSES.  THE EXAMPLE DISPLACES THE   
           CONTENTS OF THE SCREEN BY TWO BYTES.


      BPUT

HOW:       BPUT [ # ] I,adr,cnt

EG:        OPEN "O",#1,"SCREEN.DAT"
           BPUT #1,XBIOS(3)+16000,16000
           BPUT #1 XBIOS(3),16000
           CLOSE #1

PURPOSE:   READS FROM AN AREA OF MEMORY OUT TO A DATA CHANNEL.
           'I' IS A CHANNEL NUMBER.
           'cnt' BYTES ARE READ FROM ADDRESS 'adr' AND GIVEN OUT
           ON A DATA CHANNEL.


      CLR

HOW:       CLR var [ ,var ]

EG:        CLR A,B,C%,D!,E$

PURPOSE:   DELETES VARIABLES. THE EXAMPLE ABOVE SETS THE SPECIFIED
           VARIABLES (NOT ARRAYS) TO ZERO AND IS THE SAME AS:-
           
           A=0
           B=0
           C%=0
           D!=0
           E$=""


      CRSCOL  CRSLIN

HOW:       CRSCOL
           CRSLIN

EG:        CX=CRSCOL
           CY=CRSLIN
           PRINT AT(9,9);"TEST"           
           PRINT AT(CX,CY);

PURPOSE:   RETURNS THE CURRENT CURSOR LINE AND COLUMN.
           (SEE ALSO PRINT AT).


      DEFNUM

HOW:       DEFNUM N

EG:        DEFNUM 8
           FOR I=-1 TO 1 STEP 0.1
             PRINT I
           NEXT I

PURPOSE:   ROUNDS ALL NUMBERS BEFORE OUTPUT TO 'N' DIGITS.
           'N' IS AN INTEGER BETWEEN 3 AND 11.
           (SEE ALSO PRINT USING)


      EVEN

HOW:       EVEN N

EG:        REPEAT
             INPUT "ENTER AN EVEN NUMBER";N
           UNTIL EVEN(N)

PURPOSE:   DETERMINES WHETHER A NUMBER IS EVEN.
           (SEE ALSO ODD)


      EXEC

HOW:       EXEC flg,name,cmd,env
           EXEC (flg,name,cmd,env)
      
EG:        RESERVE FRE(0)-10000
           EXEC 0,"TEST.PRG","",""
           RESERVE FRE(0)+10000-255

PURPOSE:   LOADS AND EXECUTES MACHINE CODE PROGRAMS OR COMPILED
           PROGRAMS FROM DISC.
           flg=0 IS LOAD AND GO . flg=3 IS LOAD ONLY.
           'name' IS THE NAME OF THE PROGRAM.
           'cmd' IS COMMAND LINE (SEE BASEPAGE).
           'env' IS ENVIRONMENT STRING (USUALLY JUST "").
           THE NAMED PROGRAM IS LOADED FROM DISC, THE ABSOLUTE
           ADDRESSES ARE RELOCATED, A BASEPAGE IS CREATED AND IF
           REQUIRED THE PROGRAM IS RUN.
           IF EXEC IS USED AS A FUNCTION THE RESULT IS THE
           RETURNED VALUE FROM THE PROGRAM OR, WHEN flg=3 THE
           BASEPAGE ADDRESS OF THE LOADED PROGRAM.
           (SEE ALSO RESERVE AND HIMEM).


      FALSE

HOW:       FALSE

EG:        FLAG!=FALSE

PURPOSE:   CONSTANT 0. THIS IS SIMPLY ANOTHER WAY OF EXPRESSING
           THE VALUE OF A CONDITION WHEN IT IS FALSE AND IS EQUAL
           TO ZERO.
           (SEE ALSO TRUE).


      FORM INPUT AS

HOW:       FORM INPUT n AS var

EG:        PRINT "CHANGE FIELD 3"
           PRINT AT(15,15);
           FORM INPUT 15 AS FIELD3$

PURPOSE:   ALLOWS A CHARACTER STRING TO BE CHANGED DURING A 
           PRORAM. 
           'n' IS THE MAXIMUM LENGTH FOR THE STRING VARIABLE 'var'
           THIS COMMAND WORKS IN THE SAME WAY AS FORM INPUT 
           EXCEPT THAT THE OLD CONTENTS OF HE STRING VARIABLE IS
           GIVEN OUT TO BE CHANGED.
           (SEE ALSO FORM INPUT)

      
      HIDEM

HOW:       HIDEM

EG:        HIDEM
           DO
             PLOT MOUSEX,MOUSEY
           LOOP

PURPOSE:   SWITCHES OFF THE MOUSE POINTER.
           (SEE ALSO SHOWM).


      HIMEM

HOW:       HIMEM

EG:        SEE EXECUTE 

PURPOSE:   RETURNS THE ADDRESS OF THE AREA OF MEMORY WHICH IS  NOT 
           REQUIRED BY GFA BASIC.
           BASIC OCCUPIES THE MEMORY BETWEEN BASEPAGE AND HIMEM.
           WITH HIIEM ONE CAN DETERMINE THE FIRST ADDRESS ABOVE
           BASIC WHICH IS FREE (NORMALLY 16384 BYTES BELOW THE
           SCREEN AREA).
           ABOVE HIMEM THERE SHOULD BE AT LEAST 4000 BYTES FREE
           BECAUSE THE FILESELCT BOX AND OTHER GEM CALLS REQUIRE
           THIS MUCH SPACE.
           UNFORTUNATELY THE EXACT AMOUNT REQUIRED IS NOT 
           DOCUMENTED BY ATARI, BUT EXPERIMENTS HAVE SHOWN THAT IT
           REQUIRES AT LEAST 2500 BYTES.

      
      INP?

HOW:       INP?(N)

EG:        IF INP?(1)
             @Routine
           ENDIF

PURPOSE:   DETERMINES THE INPUT STATUS OF A PERIPHERY.
           'N' IS THE NUMBER OF AN INTERFACE (0=LST: 1=AUX: 2=CON:
           3=MID: ). THE FUNCTION RETURNS THE VALUE 0 IF A BYTE
           IS PRESENT OTHERWISE -1.
           THE EXAMPLE CALLS A SUBROUTINE IF SOMETHING HAS ARRIVED
           AT THE SERIAL PORT.
           (SEE ALSO OUT?)


      MONITOR

HOW:       MONITOR [ N ]

PURPOSE:   CALLS A MONTIOR RESIDENT IN MEMORY OR A COMMAND 
           EXTENSION.
           WITH THIS COMMAND A MINITOR OR DEBUGGER IS CALLE UP IF
           IT HAS SUITABLY SET THE ILLEGAL INSTRUCTION VECTOR SO
           THAT THE MSB OF THE VECTOR IS ZERO BEFORE LOADING 
           GFA BASIC (THIS IS DONE, FOR EXAMPLE, BY THE DEBUGGER
           IN THE ATARI DEVELOPEMENT SYSTEM).
           IT IS POSSIBLE TO PASS ON THE INTEGER VALUE 'N' IN 
           REGISTER D0 AND THEREFORE WRITE COMMAND EXTENSIONS.
           IN ADDITION TO THIS IN A0 THE ADDRESS OF A POINTER
           TABLE IS PASSED ON HICH POINTS TO THE EIGHT VARIABLE
           TYPES (SEE TYPE). THESE EIGHT POINTERS ARE ALSO 
           AVAILABLE FOR THE COMPILER.


      ODD

HOW:       ODD(N)
      
EG:        REPEAT
             INPUT "ENTER AN ODD NUMBER ";N
           UNTIL ODD(N)

PURPOSE:   DETERMINES WHETHER A NUMBER IS ODD.
           (SEE ALSO EVEN)


 
      ON MENU BUTTON

HOW:       ON MENU BUTTON C,M,S GOSUB proc

EG:        ON MENU BUTTON 8,1,1 GOSUB button
           DO
             ON MENU
           LOOP
           PROCEDURE button
             PRINT MENU(15)'              !NUMBER OF CLICKS
             PRINT MENU(10)'MENU(11)      !X,Y
             IF MENU(15)=4                !EXIT ONLY ON
               END                        !FOUR CLICKS
             END IF
           RETURN

PURPOSE:   RETURNS MOUSE CLICKS.
           C=MAX. NUMBER OF CLICKS TO BE COUNTED.
           M=MASK (1=LEFT 2=RIGHT 3=BOTH).
           S=STATUS (AS FOR 'M')
           IN THE EXAMPLE A MAXIMUM OF 8 CLICKS IS EXPECTED.
           WHEN THE MOUSE IS CLICKED, THE NUMBERR OF CLICKS AND
           THE MOUSE POSITION IS SHOWN. IF THE NUMBER OF CLICKS
           IS 4 THEN THE PROGRAM ENDS.


      OPTION   OPTION BASE 0   OPTION BASE 

HOW:       OPTION BASE 0
           OPTION BASE 1
           OPTION [ " ]TEXT[ " ]

EG:        OPTION "TRAPV +"
           OPTION BASE 1
           DIM A(9)
           FOR I=1 TO 9
             A$(I)=STR$(I)
           NEXT I

PURPOSE:   CHANGES THE FIELD ARRAY BASE OR CONTROL FOR THE 
           COMPILER. OPTION BASE 0/1 ALLOWS THE LOWER LIMIT FOR
           FIELD DIMENSIONING TO BE CAHNGED FROM 0 TO 1.
           SOME PROGRAMS CAN SAVE A FEW BYTES FOR THE ZERO
           ELEMENT. 
           WITH OPTION "TEXT" CONTROL COMMANDS CAN BE PASSED ONTO
           THE COMPILER.

      
      OUT?

HOW:       OUT?(N)

EG:        DO
             OUT 0,0                      !IGNORED
             EXIT IF OUT?(0)
             PRINT "PRINTER ON !!!!"
           LOOP

PURPOSE:   DETERMINES THE OUTPUT STATUS OF A PERIPHERY.
           THIS FUNCTION RETURNS 0 IF A CHARACTER CAN BE OUTPUT.
           IN  THIS  EXAMPLE  THE  READINESS  OF  THE  PRINTER  IS 
           CHECKED.
           (SEE ALSO INP?)

      
      RESERVE

HOW:       RESERVE n

EG:        see EXEC

PURPOSE:   INCREASES OR DECREASES THE MEMORY USED BY BASIC

           'n' IS A NUMERIC EXPRESSION WHICH DETERMINES HOW BIG
           FRE(0) SHOULD BE AFTER THIS COMMAND.
           AS 'HIMEM' CHANGES IN STEPS OF 256, FRE(0) CAN BE UPTO
           255 BYTES LONG.  WITH THIS COMMAND AREAS OF MEMORY CAN
           BE PROTECTED FROM ACCESS VIA BASIC AND CAN BE USED, 
           FOR EXAMPLE, FOR MACHINE CODE PROGRAMS OR RSC FILES.
           FOR AREAS CONTAINING PURELY DATA MALLOC() - that is -
           (adr=GEMDOS(&48,1:number) SHOULD BE USED TO PROTECT
           AGAINST ACCESS VIA GEM (fileselect, alert, etc)

           (see HIMEM, EXEC)


      SGET

HOW:       SGET var

EG:        SGET SCREEN1$
           FOR I=1 TO 100
             PRINT I'
           NEXT I
           SGET SCREEN2$
           DO
             SPUT SCREEN1$
             SPUT SCREEN2$
           LOOP

PURPOSE:   FAST READING OF THE ENTIRE SCREEN AREA INTO A STRING
           VARIABLE.
           (SEE ALSO SPUT, GET, PUT AND BMOVE)

           
      SHOWM

HOW:       SHOWM

EG:        SHOWM
           DO
             PLOT MOUSEX,MOUSEY
           LOOP

PURPOSE:   MAKES THE MOUSE SYMBOL APPEAR.
           (SEE ALSO HIDMEM)


      SPUT

HOW:       SPUT var

EG:        SEE SGET

PURPOSE:   FAST COPYING OF A 32000 BYTE STRING INTO THE SCREEN
           AREA.
           (SEE ALSO SGET, PUT, GET AND BMOVE)


      TRUE

HOW:       TRUE

EG:        FLAG!=TRUE

PURPOSE:   CONSTANT 0. THIS IS SIMPLY ANOTHER WAY OF EXPRESSING
           THE VALUE OF A CONDITION WHEN IT IS TRUE AND IS EQUAL
           TO ZERO.
           (SEE ALSO FALSE).
   
             
      TYPE

HOW:       TYPE(ptr)
          
EG:        SEE *

PURPOSE:   DETERMINES THE TYPE OF THE VARIABLE AT WHICH A POINTER
           IS SET.
           'ptr' IS AN INTEGER EXPRESION (USUALLY *var).
           TYPE(ptr) RETURNS A CODE ACCORDING TO THE TYPE OF
           VARIABLE TO WHICH 'ptr' IS POINTING.
           0=var  1=var$  2=var%  3=var!  4=var()  5=var$()
           6=var%()  7=var!().
           ON ERRORS -1 IS RETURNED.
           (SEE ALSO *)


      VDIBASE

HOW:       VDIBASE

PURPOSE:   DANGEROUS POKES!
      
           DETERMINES THE ADDRESS ABOVE THE AREA USED BY BASIC
           AND THE REQUIRED TABLES AND VARIABLES.
           THIS IS THE POINT FROM WHICH THIS VERSION OF GEM KEEPS
           PARAMETERS FOR THE VDI (TEXT STYLE, CLIPPING etc.).
           AFTER THIS FOLLOWS THE BASIC PROGRAM.
           BY USE OF PEEK AND POKE IN THIS AREA, VARIOUS EFFECTS
           (AND ALSO NASTY CRASHES !) CAN BE OBTAINED.


      VOID

HOW:       VOID exp

EG:        VOID FRE(0)
           VOID INP(2)

PURPOSE:   SUBSTITUTE FOR DUMMY=  . (FASTER, ESPECIALLY FOR THE
           COMPILER).
           THIS COMMAND PERFORMS A CALCULATION AND FORGETS THE
           RESULT, THIS MAY SOUND SILLY BUT THERE ARE OCCASIONS
           WHEN THIS COMMAND IS REQUIRED.
           FOR EXAMPLE, FORCED GARBAGE COLLECTION (FRE(0)) OR
           WAITING FOR A KEYSTROKE (INP(2)) OR CALLING VARIOUS
           BIOS-, XBIOS, GEMDOS OR C: ROUTINES WHICH HAVE NO
           PARAMETERS.

      
      VSYNC

HOW:       VSYNC

PURPOSE:   ENABLES SYNCHRONIZATION WITH THE SCREEN OR CAN BE 
           USED AS A PAUSE.
           HALTS THE PROGRAM UNTIL THE NEXT VERTICAL SYNC PULSE
           IS RECEIVED, i.e. UNTIL THE PICTURE IS COMPLETE ON
           THE SCREEN. THIS CAN HELP AVOID FLICKERING OF THE
           SCREEN DURING ANIMATIONS (eg. WITH GET/PUT) BUT THE
           NEXT SCREEN MUST BE PUT ONTO THE SCREEN VERY QUICKLY
           THIS FUNCTION IS THE SAME AS VOID XBIOS(37).

                  
             
