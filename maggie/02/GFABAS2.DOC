				
			GFA BASIC COMMANDS #2
				by Michael Schuessler

Here we go again with some more GFA Basic commands for you.
I hope that they are of some use to you as I did not have
any response yet.

      EOF
HOW:       EOF ([ # ] N)

EG:        OPEN "O",#1,"DATA"
           PRINT #1,"BEST BEFORE 17/8/26"
           CLOSE #1
           OPEN "I",#1,"DATA"
           DO
             PRINT INP(#1),EOF(#1)
             EXIT IF EOF(#1)
           LOOP
           END

PURPOSE:   DETERMINES WHETHER THE FILE POINTER FOR THE FILE WITH
           CHANNEL NUMBER 'N' IS AT THE END OF THE FILE.
           'N' IS AN INTEGER BETWEEN 0 & 99 WHICH REFERS TO THE
           CHANNEL NUMBER OF A FILE OPENED WITH THE OPEN COMMAND.
           THE LINE:  EXIT IF EOF(#1)  ABOVE AVOIDS THE ERROR
           MESSAGE: "END OF FILE REACHED EOF".
           THIS FUNCTION CAN ONLY BE USED WITH DISC FILES.
           (NOT FOR CON: LST: etc.).


      ERASE
HOW:       ERASE FIELD()

EG:        DIM A(100,50,5)
           PRINT FRE(0)
           ERASE A()
           PRINT FRE(0)
           DIM A(3000)

PURPOSE:   DELETES AN ARRAY AND RELEASES THE DIMENSIONED AREA.
           IF AN ARRAY HAS BEEN DIMENSIONED WITH DIM IT CANNOT
           BE RE-DIMENSIONED. THE ERASE COMMAND DELETES THE ARRAY
           AND THEREFORE ALLOWS IT TO BE DIMENSIONED AGAIN.
           IF AN ARRAY IS NO LONGER NEEDED FOR THE REST OF THE
           PROGRAM, AND THE AVAILABE MEMORY IS SMALL, IT IS A 
           GOOD IDEA TO ERASE IT AND FREE THE RESERVED MEMORY.

      
      ERR
HOW:       ERR

EG:        ON ERROR GOSUB Error-routine
           REM ATTEMPT TO CALCULATE THE SQUARE ROOT OF -1
           PRINT SQR(-1)
           PROCEDURE Error-routine
             PRINT "ERROR NUMBER ";ERR
           RETURN

PURPOSE:   RETURNS THE ERROR CODE OF ANY ERROR THAT HAS OCCURED.
           'ERR' IS A RESERVED NAME AND CANNOT BE USED AS A 
           VARIABLE.
      
           SEE ALSO FATAL, ERROR AND ON ERROR


      ERROR
HOW:       ERROR N

EG:        PRINT "ENTER ERROR NUMBER ";
           INPUT E
           ERROR E

PURPOSE:   SIMULATES THE OCCURENCE OF THE ERROR WITH THE ERROR
           CODE 'N' AND THE APPROPRIATE ERROR MESSAGE IS THEN
            DISPLAYED.
           'N' IS AN INTEGER BETWEEN -128 & 127


      EXIST
HOW:       EXIST ("FILESPEC")

EG:        PRINT EXIST("A:ZIRCON.DOC")

PURPOSE:   DETERMINES WHETHER A PARTICULAR FILE IS PRESENT ON
           A DISC.
           'FILESPEC' IS A FILENAME WHICH ALLOWS THE SAME
           SPECIFICATIONS AS THE DIR COMMAND.
           IF THE FILE IS PRESENT THE VALUE -1 IS RETURNED, IF
           NOT THEN THE VALUE 0 IS RETURNED.


      EXIT
HOW:       EXIT IF Condition

EG:        DO
             A=A+1
             PRINT A
             EXIT IF A=20
           LOOP

PURPOSE:   ENABLES THE EXIT FROM A LOOP.
           IF THE EXIT COMMAND IS MET WITHIN A LOOP AND THE EXIT
           CONDITION IS MET, THE PROGRAM CONTINUES FROM THE FIRST
           COMMAND AFTER THE LOOP.
           THIS COMMAND ALLOWS ANY LOOP TO BE LEFT ie: FOR...NEXT
           DO...LOOP,  REPEAT...UNTIL AND  WHILE...WEND.


      EXP
HOW:       EXP(X)

EG:        PRINT EXP(1)
           PRINT EXP(0.5)
           PRINT EXP(-2)

PURPOSE:   CALCULATES THE VALUE OF AN EXPONANT
               
              
      FATAL
HOW:       FATAL

EG:        ON ERROR GOSUB Error-routine
           ERROR 5
           PROCEDURE Error-routine
             PRINT "FATAL=";FATAL
           RETURN

PURPOSE:   RETURNS THE VAUE 0 OR -1 ACCORDING TO THE TYPE OF
           ERROR.
           ON NORMAL ERRORS THE FUNCTION RETURNS 0. THE VALUE -1
           IS RETURNED ON ALL ERRORS WHERE THE ADDRESS OF THE
           LAST EXECUTED COMMAND IS NO LONGER KNOWN.
           NORMALLY THIS IS AN OPERATING SYSTEM ERROR WHICH
           WOULD LEAD TO THE 'BOMB' ERRORS AND THE BREAKDOWN OF 
           THE PROGRAM.

      
      FIELD
HOW:       FIELD [#]N,expression AS svar .......

EG:        OPEN "R",#1,"TEST",50
           FIELD #1,20 AS A$,30 AS B$
           FOR I=1 TO 4
             INPUT "NAME1,NAME2: ",V$,N$
             LSET A$=V$
             LSET B$=N$
             PUT #1,I            
           NEXT I
           FOR I=4 DOWNTO 1
             GET #1,I
             PRINT A$,B$
           NEXT I

PURPOSE:   DIVIDES RECORDS INTO FIELDS.
           'N' IS THE CHANNEL NUMBER.
           'expression'  DEFINES THE FIELD LENGTH.
           'Svar' IS A STRING VARIABLE WHICH ACCEPTS A DATA FIELD.
           THE SECTION 'expression AS svar' CAN BE REPEATED IF THE
           RECORD IS TO BE DIVIDED INTO SEVERAL FIELDS. THE SUM OF
           THE FIELDS SHOULD EQUAL THE RECORD LENGTH.
           EACH OPEN DATA CHANNEL MAY HAVE ONLY ONE FIELD COMMAND.

           THE EXAMPLE CREATES A NAME FILE WHICH IS THEN READ IN
           REVERSE ORDER.
           GFA BASIC DOES NOT USE A BUFFER OF ITS OWN FOR THIS
           TYPE OF FILE ACCESS. THEREFORE THE COMMAND VARPTR(#N)
           IS NOT POSSIBLE.


      FILES
HOW:       FILES [ "FILESPEC" [ TO "FILE" ]] 
           
EG:        FILES "A:*.*" TO "A:CONTENTS"
           FILES "A:*.*" TO "LST:"

PURPOSE:   LISTS THE FILES ON A DISC.
           THIS COMMAND WORKS ALMOST THE SAME AS DIR, THE 
           DIFFERENCE BEING THAT FILES COMPILES A DETAILED
           DATA LISTING WHICH CONTAINS ITS LENGTH, THE TIME AND
           DATE AS WELL AS THE FILENAME
           (SEE DIR FOR FURTHER INFORMATION).


      FILESELECT
HOW:       FILESELECT "FILESPEC","FILENAME",X$

EG:        DO
             FILESELECT "/*.*",B$,A$
             EXIT IF A$=""
             PRINT A$
           LOOP

PURPOSE:   CREATES A FILESELECT BOX ON THE SCREEN
           'FILESPEC' IS THE SO-CALLED SEARCH PATH. THIS IS A
           FILE NAME WHICH ALLOWS THE USE OF THE SPECIFICATIONS
           DESCRIBED IN DIR AND THE HIERACHICAL FILE SYSTEM (/).
           'FILESPEC' HAS TO CONTAIN AT LEAST "/*.*". IN THIS 
           CASE ALL THE FILES IN THE ROOT DIRECTORY OF THE CURRENT
           DISC DRIVE IN THE FILESELECT BOX ARE SELECTED
           'X$' RETURNS AS CHOSEN FILENAME. IF THE ABORT BUTTON IS
           IS CLICKED THEN 'X$' IS RETURNED AS AN EMPTY STRING.

      
      FILL
HOW:       FILL X,Y

EG:        BOX 10,10,100,100
           DRAW 10,10,100,100
           FILL 50,30
      
PURPOSE:   FILLS A BORDERED AREA WITH A PATTERN COMMENCING AT
           THE CO-ORDINATES 'X,Y',. 
           THE FILL PATTERN CAN BE CHOSEN WITH THE COMMAND
           DEFFILL.


      FIX
HOW:       FIX(X)

EG:        A=3.1415926
           PRINT FIX(A)
           PRINT FIX(-1.99)

PURPOSE:   RETURNS THE INTEGER OF 'X' AFTER IT HAS BEEN ROUNDED.
           SAME AS INT(X) FOR POSITIVE NUMBERS BUT FOR NEGATIVE
           NUMBERS INT(-1.99)=-2 AND FIX(-1.99)=1.
           FIX IS IDENTICAL TO THE FUNCTION TRUNC AND COMPLEMENTS
           FRAC.


      FOR...NEXT
HOW:       FOR var=A [ DOWN ]TO E [ STEP S ]
           NEXT var                                                   

EG:        FOR I=3 TO 5
             FOR J=5 DOWNTO 3
               FOR K=1 TO 5 STEP 2
                 PRINT I,J,K
               NEXT K
             NEXT J
           NEXT I

PURPOSE:   CREATES A LOOP WHICH IS EXECUTED AS MANY TIMES AS
           SPECIFIED AT THE BEGINNING OF THE LOOP.
           'var' IS GIVEN THE VALUE 'A' AND THE COMMANDS BETWEEN
           THE FOR AND NEXT STATEMENTS ARE EXECUTED.
           WHEN NEXT IS ENCOUNTERED 'var' IS INCREASED BY 'S'
           (IF 'S' ISN'T GIVEN A VALUE IT DEFAULTS TO 1).
           IF 'S' HAS A NEGATIVE VALUE 'var' IS DECREMENTED.
           THE OPTIONAL COMMAND DOWNTO CAN BE USED INSTEAD OF
           SETTING 'S' TO -1.
           THE USE OF AN INTEGER VARIABLE (eg. I%) WILL SPEED
           UP THE EXECUTION OF A LOOP BY UP TO 30%.


      FORM INPUT
HOW:       FORM INPUT N,var

EG:        PRINT "ENTER YOUR NAME"
           PRINT "(MAX 15 LETTERS)"
           PRINT AT(15,15);
           FORM INPUT 15,NAME$
           PRINT "YOUR NAME IS ";NAME$

PURPOSE:   ENABLES THE INSERTION OF A CHARACTER STRING (LIMITED 
           TO 255 CHARACTERS IN LENGTH) DURING PROGRAM EXECUTION.
           'N' REPRESENTS THE MAXIMAL LENGTH OF THE CHARACTER
           STRING.
           'var' IS THE NAME OF THE STRING VARIABLE.
           BOTH <DELETE> AND <BACKSPACE> CAN BE USED AS CAN THE 
           ARROW KEYS.
           THE BUZZER SOUNDS WHEN THE MAX LENGTH IS REACHED.

      
      FRAC
HOW:       FRAC(X)

EG:        A=-10.1234
           PRINT FRAC(A)
           PRINT FRAC(3.1415926)
           PRINT TRUNC(A)+FRAC(A)

PURPOSE:   RETURNS THE DIGITS AFTER THE DECIMAL POINT IN A 
           NUMBER. 
           'X' CAN BE ANY NUMERIC EXPRESSION. IF 'X' IS AN
           INTEGER THEN A ZERO IS RETURNED.
           THEREFORE FRAC(X)=X-TRUNC(X)

      
      FRE
HOW:       FRE(X)
      
EG:        PRINT FRE(A%)
           DIM N$(1000)  
           PRINT FRE(0)

PURPOSE:   RETURNS THE AMOUNT OF MEMORY FREE (IN BYTES)
           THE PARAMETER 'X' IS DISREGARDED.
           IF THE FUNCTION FRE IS USED GFA BASIC CALCULATES
           THE AMOUNT OF FREE MEMORY AFTER DELETION OF ALL
           UNUSED AREAS (GARBAGE COLLECTION).


  
     FULLW
HOW:       FULLW N

EG:        FULLW2

PURPOSE:   ENLARGES WINDOW 'N' TO FULL SCREEN SIZE.
           'N' IS THE WINDOW NUMBER. IF THE WINDOW HAS NOT
           YET BEEN OPENED, THIS TAKES PLACE AUTOMATICALLY.


      GET
HOW:       GET [ # ] N [ ,I ]

EG:        SEE FIELD

PURPOSE:   READS A RECORD FROM A RANDOM ACCESS FILE.
           'N' IS THE CHANNEL NUMBER (1 TO 99)
           'I' IS NUMBER OF THE RECORD TO BE READ (1 TO 65535)
           IF 'I' IS NOT GIVEN THEN THE NEXT RECORD IN THE FILE
           WILL BE READ.


      GOSUB
HOW:       GOSUB name [ (LIST OF EXPRESSIONS) ]

ABBR:      GO or @

EG:        PRINT "MAIN PROGRAM"
           GOSUB Routine.1
           PRINT "BACK FROM 1"
           PROCEDURE Routine.1
             PRINT "PROCEDURE 1"
             GOSUB Routine.2(3,2)
             PRINT "BACK FROM 2"
             PRINT A,B
           RETURN
           PROCEDURE Routine.2(A,B)
             PRINT A,B
             PRINT "PROCEDURE 2"
           RETURN

PURPOSE:   BRANCHES TO THE PROCEDURE CALLED 'name'
      
           A PROCEDURE NAME CAN BEGIN WITH A DIGIT AND CONTAIN
           LETTERS, NUMBERS, DOTS AND THE UNDERLINE DASH.
           '(LIST OF EXPRESSIONS)' CONTAINS THE VALUES OF ANY
           LOCAL VARIABLES TO BE PASSED TO THE PROCEDURE.
           WHEN THE INTERPRETER COMES ACCROSS A GOSUB COMMAND,
           IT BRANCHES TO THE PROCEDURE NAMED IN THE GOSUB.
           IT IS POSSIBLE TO CALL FURTHER PROCEDURES WHILST IN
           A PROCEDURE, IT IS EVEN POSSIBLE TO CALL THE PROCEDURE
           ONE IS IN AT THE TIME (RECURSIVE CALL).

           THE ABOVE EXAMPLE CALLS THE PROCEDURE NAMED 'Routine.1'
           FROM THE MAIN PROGRAM. FROM WITHIN THIS PROCEDURE, THE 
           PROCEDURE 'Routine.2' IS CALLED AND THE VALUES 2 & 3
           ARE GIVEN TO THE LOCAL VARIABLES A & B.

           SEE ALSO PROCEDURE, RETURN AND LOCAL
                  
           
      GOTO
HOW:       GOTO label            

EG:        Start:
           PRINT "ENDLESS LOOP"
           GOTO start

PURPOSE:   ALLOWS AN UNCONDITIONAL JUMP TO A LABEL.
           'label' MUST END IN A COLON AND CAN CONSIST OF LETTERS,
           NUMBERS, DOTS, DASHES AND CAN BEGIN WITH A DIGIT.
                      
           
  
 
      GRAPHMODE
HOW:       GRAPHMODE N

EG:        DEFFILL 1,3,4
           PBOX 10,100,50,250
           GRAPHMODE 4
           DEFFILL 1,3,5
           PBOX 120,200,200,300
           GRAPHMODE 1
           PBOX 120,180,200,50
           DO
             IF K=1 THEN
               GRAPHMODE 1
             ELSE
               GRAPHMODE 3
             ENDIF
             MOUSE X,Y,K
             CIRCLE X,Y,50
             CIRCLE X,Y,50
           LOOP

PURPOSE:   SETS THE GRAPHIC MODE 1 TO 4.

           1=REPLACE     2=TRANSPARENT
           3=Xor         4=REVERSE TRANSPARENT

           THIS COMMAND DETERMINES THE GRAPHIC MODE OF THE SCREEN
           IT IS IMPORTANT WHEN PICTURES ARE TO BE DRAWN ON TOP
           OF EACH OTHER.

      
      HARDCOPY
HOW:       HARDCOPY
      
EG:        GRAPHMODE 3
           FOR I=0 TO 800
             BOX I MOD 640, I MOD 400,639-I MOD 640,399-I MOD 400
           NEXT I
           HARDCOPY

PURPOSE:   PRINTS THE SCREEN (SAME AS PRESSING <ALT> & <HELP> ).


      HEX$
HOW:       HEX$(X)

EG:        A=-1
           B=&022
           PRINT HEX$(A)
           PRINT HEX$(B)

PURPOSE:   CHANGES THE VALUE OF 'X' INTO A STRING EXPRESSION
           WHICH CONTAINS THE VALUE OF 'X' IN HEXADECIMAL FORM.
           
           SEE ALSO BIN$, OCT$, AND STR$


      IF
HOW:       IF condition [ THEN ]
             program block
             [ ELSE ]
               [ program block ]
           ENDIF

EG:        INPUT A,B
           IF A=3
             PRINT "YOU HAVE WON THE "
             IF B=3 THEN
               PRINT "JACKPOT !"
             ELSE
               PRINT "BOOBY PRIZE !"
             END IF
           ELSE
             PRINT "TRY AGAIN "
           ENDIF
           PRINT "SEE YOU SOON "

PURPOSE:   DIVIDES A PROGRAM UP INTO DIFFERENT BLOCKS DEPENDING
           ON HOW IT RELATES TO THE 'condition'.
           FOR A BETTER UNDERSTANDING OF THIS COMMAND IT WOULD
           BE A GOOD IDEA TO TRY THE ABOVE EXAMPLE.

      INC
HOW:       INC var

EG:        DO
             INC A
             EXIT IF A=100
           LOOP
           PRINT A

PURPOSE:   INCREASES THE VALUE OF 'var' BY 1. THE SAME AS
           var=var+1 BUT EXECUTES APROX 3.5 TIMES FASTER


      INFOW
HOW:       INFOW N,"STRING"

EG:        INFOW 2,"SMOKING CAN DAMAGE YOUR HEALTH"

PURPOSE:   ALLOCATES THE (NEW) INFORMATION LINE TO THE WINDOW
           WITH THE NUMBER 'N'. 
           IF THE STRING IS EMPTY THEN THE LINE IS REMOVED
           ALTOGETHER. 
           AS THE INFO LINE CANNOT BE SWITCHED ON AND OFF (GEM)
           WHEN THE WINDOW IS OPENED, INFOW HAS TO BE USED IN 
           FRONT OF OPENW WHEN AN INFORMATION LINE IS REQUIRED.
           IF THE COMMAND INFOW,N,"" IS USED ("" = NULL STRING)
           BEFORE OPENW THEN THE WINDOW WILL HAVE NO INFO LINE.


      INKEY$
HOW:       INKEY$

EG:        DO
             REPEAT
               Z$=INKEY$
             UNTIL Z$<>""
             PRINT LEN(Z$)
             PRINT LEFT$(Z$)''ASC(Z$),
             PRINT RIGHT$(Z$)''ASC(RIGHT$(Z$))
           LOOP

PURPOSE:   READS A CHARACTER FROM THE KEYBOARD.
           THIS FUNCTION RETURNS A STRING WHICH IS 2,1 OR 0
           CARACTERS LONG.
           IF THE KEY IS A NORMAL KEY, THEN ONE CHARACTER IS
           RETURNED CONTAINING THE ASCCII CODE.
           IF THE KEY IS A FUNCTION KEY OR HELP, UNDO etc.
           THEN TWO CHARACTERS ARE RETURNED. THE FIRST IS ALWAYS
           ASCCII CODE ZERO AND THE KEY CODE IS IN THE SECOND.
           


      INP
HOW:       INP(X)
           INP(#N)

EG:        OPEN "O",#1,"DAT"
           PRINT #1,"ABC"
           CLOSE #1
           OPEN "I",#1,"DAT"
           PRINT INP(#1)
           PRINT "PRESS ANY KEY TO CONTINUE"
           PRINT INP(2)

PURPOSE:   READS ONE BYTE FROM THE PERIPHERY OR FROM A FILE.
           'X' MUST HAVE A VALUE BETWEEN 0 & 5
                         
           0= LST:  1= AUX:  2= CON:  3= MID: 4=NOT POSSIBLE
           5= CON:

           THE FUNCTION INP(X) READS ONE BYTE FROM THE PERIPHERY          
           NAMED IN 'X' AND THE PROGRAM WAITS UNTIL A BYTE IS 
           ACCESSED (eg. WITH X=2 UNTIL A KEY IS PRESSED).
           INP(#N) READS ONE BYTE FROM THE FILE WITH THE DATA
           CHANNEL 'N'.

           THE FUNCTION var=BIOS(1,N) CAN BE USED TO SEE IF A 
           BYTE IS AVAILABLE.


      INPUT
HOW:       INPUT [ "TEXT"; (; or ,) ] VAR [ ,VAR.... ]              
           INPUT #N,var [ ,var.... ]

EG:        INPUT K
           PRINT AT(5,15);
           INPUT "ENTER YOUR NAME ";N$
           INPUT "Age and Address: ",A,W$

PURPOSE:   ALLOWS ENTRY OF DATA DURING PROGRAM EXECUTION

           WHEN PRINTING TEXT BEFORE INPUT, IT MUST ALWAYS BE IN
           INVERTED COMMAS.  IF THERE IS A SEMICOLON BETWEEN THE
           'TEXT' AND 'VAR' A QUESTION MARK AND A SPACE WILL BE
           DISPLAYED BEFORE THE CURSOR.  IF A COMMA IS USED, THE
           CURSOR WILL BE DIRECTLY AFTER THE LAST CHARACTER OF
           'TEXT'

           IF WRONG INFORMATION IS ENTERED FOR THE TYPE OF 'VAR',
           A BUZZER WILL SOUND AND ANOTHER ATTEMPT CAN BE MADE.

           IF THE INFORMATION HAS BEEN TAKEN FROM A FILE (USING
           INPUT #N) AN ERROR MESSAGE WILL BE DISPLAYED. A STRING
           CAN BE UPTO 255 CHARACTERS LONG.
           SPECIAL CHARACTERS CAN BE SEARCHED FOR AND ENTERED IN
           THREE DIFFERENT WAYS, BY PRESSING :-

           - <ALT> KEY TOGETHER WITH ANOTHER KEY
           - <CONTROL> AND <S> TOGETHER, FOLLOWED BY ANOTHER KEY
           - <CONTROL> AND <A> TOGETHER, FOLLOWED BY THE ASCII
             CHARACTER CODE OF THE CHOSEN KEY

           THE BEGINNING AND END OF THE TEXT CAN BE REACHED BY
           USING THE UP AND DOWN ARROR KEYS.
           IF THE INFORMATION ENTERED CONTAINS A COMMA, THEN ONLY
           THE PART BEFORE THE COMMA WILL BE ACCEPTED, HOWEVER IF
           IF THE STRING CONTAINING COMMAS IS ENTERED BETWEEN 
           INVERTED COMMAS, THE WHOLE STRING WILL BE ACCEPTED
           WITHOUT THE INVERTED COMMAS.


      INPUT$
HOW:       INPUT$(X[,#N])

EG:        OPEN "O",#1,"DAT"
           PRINT #1,"GFA BASIC"
           CLOSE #1
           OPEN "I",#1,"DAT"
           PRINT INPUT$(3,#1)
           PRINT "TYPE IN 5 CHARACTERS"
           PRINT INPUT$(5)

PURPOSE:   READS 'X' FROM THE KEYBOARD OR FILE AS A STRING

           'X' IS AN INTEGER BETWEEN 0 AND 32767 (STRING LENGTH)
           'N' IS AN INTEGER BETWEEN 0 AND 99 WHICH REPRESENTS
           THE DATA CHANNEL NUMBER OPENED WITH 'OPEN'
           IF THE OPTIONAL PART IS NOT USED, THE COMMAND FORMS A
           STRING FROM 'X' CHARACTERS FROM THE KEYBOARD.  IF THE
           OPTIONAL PART '#N' IS USED THEN A STRING OF 'X' 
           CHARACTERS WILL BE READ FROM THE FILE #N


      INSTR
HOW:       INSTR([N,]A$,B$)      OR       INSTR(A$,B$[,N])

EG:        N$="GFA BASIC"
0           S$="BASIC"
           PRINT INSTR(N$,"A")
           PRINT INSTR(4,N$,"A")
           PRINT INSTR("GFA BASIC","FB")
           PRINT INSTR(N$,S$)

PURPOSE:   SEARCHES TO SEE IF B$ IS PRESENT IN A$ AND RETURNS
           ITS POSITION.
           'N' IS A NUMERIC EXPRESSION INDICATING THE POSITION IN
           A$ AT WHICH THE SEARCH IS TO BEGIN.  IF 'N' IS NOT 
           GIVEN, THE SEARCH BEGINS AT THE FIRST CHARACTER OF A$.

           IF B$ IS FOUND IN A$ THE START POSITION IS RETURNED.

      
      INT
HOW:       INT(X)

EG:        A=3.1415926
           PRINT INT(A)
           PRINT INT(-1.001)

PURPOSE:   DETERMINES THE LARGEST INTEGER THAT IS LESS THAN OR
           EQUAL TO 'X'
      

      KILL
HOW:       KILL "FILESPEC"

EG:        OPEN "O",#1,"WUBBISH"
           CLOSE
           FILES
           KILL "WUBBISH"
           PRINT 
           FILES

PURPOSE:   DELETES A DISC FILE (ONLY ONE AT A TIME)

 
      LEFT$
HOW:       LEFT$(STRING [ ,N ] )

EG:        N$="SOCIALISM"
           PRINT LEFT$(N$)
           PRINT LEFT$(N$,2)
           PRINT LEFT$(N$,5)

PURPOSE:   RETURNS THE FIRST CHARACTER OR FIRST 'N' CHARACTERS
           OF A STRING.


      LEN
HOW:       LEN(X$)

EG:        A$="ABCDEFGHIJKLMNOPQRST"
           PRINT LEN(A$)
           PRINT LEN(A$+"UVWXYZ")

PURPOSE:   DETERMINES THE LENGTH OF A STRING.


      LET
HOW:       [ LET ] var=expression

EG:        LET A=666
           PRINT A
           REM  OR WITHOUT THE WORD 'LET'
           A=999
           PRINT A

PURPOSE:   ASSIGNS A VARIABLE WITH HE VALUE OF AN EXPRESSION.


      LINE
HOW:       LINE X,Y,XX,YY

EG:        LINE 0,0,200, 200
           LINE 200,0,0,200

PURPOSE:   CONNECTS TWO POINTS ('X,Y' & 'XX,YY') WITH A STAIGHT
           LINE.
           THIS COMMAND IS IDENTICAL TO DRAW X,Y TO XX,YY

           SEE ALSO DEFLINE


      LINE INPUT  LINE INPUT #
HOW:       LINE INPUT [ "TEXT" ; ( , ) ]var [ ,var... ]
           LINE INPUT #N,var [,var...]

EG:        LINE INPUT K$
           LINE INPUT A$,B$,C$
           PRINT AT(15,15)
           LINE INPUT "ENTER NAME" N$
           LINE INPUT "STREET & TOWN ",S$,T$

PURPOSE:   MAKES IT POSSIBLE TO ENTER A STRING DURING PROGRAM
           EXECUTION.
           'TEXT' IS A STRING WHICH IS SHOWN ON THE SCREEN PRIOR
           TO INFORMATION BEING ENTERED.
           'var' CAN BE ANY STRING VARIABLE NAME.
           THIS COMMAND IS THE SAME AS INPUT EXCEPT THAT A COMMA 
           IS TAKEN AS PART OF THE ENTERED STRING AND NOT AS A
           SEPARATOR. ONLY <RETURN> IS REGARDED AS A SEPARATOR.


      LIST
HOW:       LIST "FILENAME"

EG:        PRINT "LIST PROGRAM TO DISC AS ASCCII CODE"
           LIST "PROG"
           PRINT "LIST PROGRAM TO SCREEN"
           LIST ""

PURPOSE:   STORES THE PROGRAM CURRENTLY IN MEMORY TO DISC IN
           ASCCII FORMAT. IF THE 'FILENAME' IS AN EMPTY STRING
           (eg. "") THEN THE LISTING IS SHOWN ON THE SCREEN.
           IN ALL OTHER CASES THIS COMAND IS THE SAME AS THE 
           EDITOR MENU OPTION SAVE,A 
           PROGRAMS WHICH ARE TO BE JOINED TOGETHER USING THE
           COMMAND MERGE MUST BE SAVE USING LIST.
           IF NO FILENAME EXTENSION IS GIVEN THEN .LST IS
           ASSUMED.


      LLIST
HOW:       LLIST

EG:        PRINT "LIST PROGRAM TO PRINTER"
           LLIST

PURPOSE:   PRINTS OUT THE LISTING OF THE CURRENT PROGRAM.


      LOAD
HOW:       LOAD "FILESPEC"

EG:        SAVE "PROGRAM"
           LOAD "PROGRAM"

PURPOSE:   LOADS A PROGRAM INTO MEMORY. IF NO EXTENSION IS GIVEN
           THEN .BAS IS ASSUMED.
           FOR 'FILESPEC' SEE DIR.


      LOC
HOW:       LOC( [ # ]N)

EG:        OPEN "O",#1,"DAT"
           PRINT #1,"1234567"
           SEEK #1,3
           PRINT LOC(#1)

PURPOSE:   RETURNS THE LOCATION OF THE FILE POINTER FOR THE
           FILE WITH THE CHANNEL NUMBER 'N'
           THE LOCATION IS GIVEN IN NUMBER OF BYTES FROM THE
           START OF THE FILE.


      LOCAL
HOW:       LOCAL var [ ,var.... ]

EG:        A=1000
           PRINT A
           GOSUB sub
           PRINT A
           PROCEDURE sub
             LOCAL A 
             I=I+1
             A=I
             PRINT A
             IF I=10 THEN 
             ELSE
               GOSUB sub
             ENDIF
             PRINT A
           RETURN

PURPOSE:   DECLARES 'var' TO BE A LOCAL VARIABLE.
           'VAR' CAN BE ANY VARIABLE  (EXCEPT A FIELD (ARRAY?)
           VARIABLE ). IF THE VARIABLE IS ASSIGNED A VALUE
           FROM WITHIN A PROCEDURE, THE VALUE OF ANY VARIABLES
           WITH THE SAME NAME USED OUTSIDE THE PROCEDURE REMAINS
           UNCHANGED.
           SEE ALSO GOSUB, PROCEDURE AND RETURN.


      LOF
HOW:       LOF ([ # ]N)

EG:        OPEN "O",#1,"DAT"
           PRINT LOF(#1)
           PRINT #1,"1234567"
           PRINT LOF(#1)

PURPOSE:   DETERMINES THE LENGTH OF THE FILE (IN BYTES) WITH 
           CHANNEL NUMBER 'N'.
           SEE ALSO OPEN


      LOG  LOG10
HOW:       LOG(X)
           LOG10(X)

EG:        A=2.718281818285
           PRINT LOG(A)
           PRINT LOG(A^2)
           PRINT LOG10(10*10*10)
           PRINT LOG10(2.456)

PURPOSE:   DETERMINES THE NATURAL LOGARITHM (LOG) OR THE LOGARITHM
           BASE 10 (LOG10) OF 'X'.


      LPOS
HOW:       LPOS(N)

EG:        FOR I=1 TO 600
             LPRINT "A";
             IF LPOS(1)=30 THEN
               LPRINT
             END IF
           NEXT I

PURPOSE:   RETURNS THE COLUMN IN WHICH THE PRINTER HEAD
           (IN THE PRINTER BUFFER) IS LOCATED.
           'N' CAN BE ANY NUMBER. THE FIRST COLUMN IS '0'
           THE VALUE RETURNED BY THIS FUNCTION WILL NOT CORRESPOND
           TO THE ACTUAL POSITION OF THE PRINTER HEAD IN EVERY 
           CASE BECAUSE FOR THIS FUNCTION ONLY THE LINES ACTUALLY
           PRINTED ARE COUNTED. CR, LF AND BS [CHR$(13,10,8)] ARE
           TREATED AS A SPECIAL CASE.


      LPRINT
HOW:       LPRINT [ expressions [ , ][ ; ][ ' ]] 
      
EG:        A$="GFA"
           B=1986
           LPRINT A$'
           LPRINT B,
           LPRINT A$,B,
           LPRINT A$,B;"GFA"
           LPRINT A$'''''B
           LPRINT USING "###.##",PI*100

PURPOSE:   PRINTS DATA ON THE PRINTER.
           'expression' IS ANY NUMBER OF EXPRESSIONS SEPARATED
           BY COMMAS OR SEMICOLONS OR APOSTROPHES. IF NONE OF 
           THESE IS GIVEN A SEMICOLON IS ASSUMED.
           THIS COMMAND IS SIMILAR TO THE PRINT COMMAND IN ALL 
           RESPECTS APART FROM THE FACT THAT THE OPTION AT(X,Y)
           CANNOT BE USED.
           SEE ALSO PRINT AND PRINT USING


      LSET
HOW:       LSET var=string

EG:        A$="AAAAAAAAA"
           B$=SPACE$(7)
           C$="GFA"
           LSET A$=C$
           LSET B$="GFA-BASIC"
           PRINT A$;B$

PURPOSE:   PUTS THE 'string' IN THE STRING VARIABLE 'var' 
           JUSTIFIED TO THE LEFT. IF THE CHARACTER STRING IS
           SMALLER THAN THE VARIABLE THEN THE UNUSED PART WILL
           CONTAIN SPACES. IF THE REVERSE IS TRUE, THEN THE
           STRING WILL BE TRUNCATED FROM THE RIGHT UNTIL IT FITS
           THE VARIABLE.
           LSET IS NORMALLY USED IN CONJUNCTION WITH FIELD WHEN
           CREATING A RELATIVE FILE. IN THIS CASE THE NUMERIC
           VALUES MUSRT BE TRANSFORMED INTO STRINGS USING MKI$,
           MKS$, MKF$ OR MKD$ BEFORE THE COMMAND LSET CAN BE USED.
           LSET IS THE OPPOSITE OF THE COMMAND RSET.


      MAX
HOW:       MAX(expression [ ,expression... ])

EG:        A=17
           B=3
           A$="AAA"
           PRINT MAX(A,B,2*2)
           PRINT MAX(A$,"AAAA")

PURPOSE:   RETURNS THE GREATEST VALUE (OR LARGEST STRING) FROM
           A LIST OF EXPRESSIONS.
           'expression' IS ANY NUMERIC OR STRING EXPRESSION.
           ALL EXPRESSIONS IN THE LIST MUST BE OF THE SAME TYPE
           (i.e ALL NUMERIC OR ALL STRING).
           IF NUMBERS ARE BEING COMPARED, THE LARGEST IS RETURNED.
           IF IT IS STRINGS THENM THE OPERATOR '>' IS USED TO
           DETERMINE THE 'LARGEST' STRING.
           THE OPPOSTIE TO MAX IS MIN


      MENU
HOW:       MENU field (n)
           MENU KILL
           MENU OFF
           MENU n,x

EG:        See ON MENU GOSUB

PURPOSE:   MAKES IT POSSIBLE TO CREATE AND MODIFY MENU STRIP

           'field' IS A ONE-DIMENSIONAL FIELD OF STRING VARIABLES
           WHICH CONTAINS THE TEXT OF THE MENU STRIP. THE FIELD OF
           STRING VARIABLES MUST BE CONSTRUCTED IN THE FOLLOWING
           WAY:

           THE MENU TITLE AND ITEMS OF THE PULL-DOWN MENU MUST BE
           ENTERED ONE AFTER THE OTHER.  AN EMPTY STRING MUST
           FOLLOW EACH MENU TITLE WITH ITS RESPECTIVE PULL-DOWN
           MENU.  TWO EMPTY MUST FOLLOW THE LAST ITEM IN THE MENU.
           
           THE FIRST MENU MUST BE ENTERED IN THE FOLLOWING WAY:
           TITLE, PROGRAM INFORMATION, A SERIES OF MINUS SIGNS TO
           SEPERATE IT FROM THE REST, 6 DUMMY STRINGS (LENGTH >0)
           FOR THE DESK ACCESSORIES.
           THE MENU STRIP IS ACTIVATED AND DISPLAYED BY USING THE
           COMMAND 'MENU field()'.  THIS MENU DE-ACTIVATED BY THE
           COMMAND 'MENU KILL'.  'MENU OFF' DISPLAYS MENU TITLES
           IN THE NORMAL WAY AGAIN IF THEY WERE DISPLAYED INVERSE.
           MENU ITEMS CAN BE ALTERED BY USING 'MENU n,x'. 'n' IS
           THE ITEM NUMBER IN THE MENU AND 'x' FOR AN INTEGER FROM
           0 TO 3.

           MENU n,0 REMOVES THE TICK FROM IN FRONT OF THE MENU
                    ITEM WHICH WAS SET WITH MENU n,1

           MENU n,1 PLACES A TICK IN FRONT OF A MENU ITEM. THERE
                    MUST BE A SPACE BEFORE THE ITEM FOR IT TO WORK

           MENU n,2 THE ITEM IS WRITTEN IN PALE LETTERS AND CANNOT
                    BE CHOSEN

           MENU n,3 THE ITEM IS WRITTEN IN NORMAL LETTERING AND
                    CAN BE CHOSEN AGAIN

           A MENU ITEM CANNOT BE CHOSEN IF IT STARTS WITH A MINUS
           SIGN. (AS IN MENU N,2). DESK ACCESSORIES CAN BE 
           DEACTIVATED BY REPLACING THE SIX DUMMY STRINGS WITH
           MINUS SIGNS. IT IS ALSO POSSIBLE TO ACTIVATE AND
           DEACTIVATE THEM WITH THE OPTIONS MENU N,3 AND MENU N,2.
           SEE ON MENU GOSUB AND THE FUNCTION MENU.

           

      MENU
HOW:       MENU(N)


EG:        SEE ON MENU GOSUB

PURPOSE:   THE   FUNCTION  MENU(N)  MAKES IT POSSIBLE TO USE THE
           PARAMETERS FROM THE ON MENU GOSUB ROUTINES.

           AFTER ON MENU THE FUNCTION RETURNS THE VAUES WHICH WERE
           RETURNED WHEN 'event_multi' WAS CALLED UP.
           
           N=0 THE NUMBER OF CLICKED PULL DOWN MENUS
           N=1 TO 8 RETURNS THE CORRESPONDING MESSAGE BUFFER
           ENTRIES
           N=9 RETURNS A FLAG WHICH INDICATES WHAT THE LAST
           OCCURENCE WAS (int_out[0]).
           N=10 & N=11 RETURN THE COORDINATES WHICH MOVE THE MOUSE
           (int_out[1 & 2]).
           N=12 RETURNS THE STATUS OF THE MOUSE KEYS
           (int_out[3]).
           N=13 RETURNS THE SATE OF THE ALT KEYS.
           N=14 RETURNS THE KEY THAT WAS CLICKED AS A WORD,
           HIGH BYTE=SCAN CODE, LOW BYTE=ASCCII CODE (int_out[5]).
           N=15 RETURNS THE NUMBER OF MOUSE CLICKS (int_out[6]).
           N=16 RETURNS THE ADDRESS OF THE MENU OBJECT TREE.

